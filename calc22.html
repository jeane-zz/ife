<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>堆栈四则运算</title>
</head>
<body>
	<script type="text/javascript">
	function isOperator(value){
		var operatorString = "+-*/%()";
		return operatorString.indexOf(value) > -1
	}

	function getPrioraty(value){
		switch(value){
			case '+':
			case '-':
				return 1;
			case '*':
			case '/':
			case '%':
				return 2;
			default:
				return 0;
		}
	}

	function prioraty(o1, o2){
		return getPrioraty(o1) <= getPrioraty(o2);
	}

	function dal2Rpn(exp){
		var inputStack = [];
		var outputStack = [];
		var outputQueue = [];

//	将算术式放入输入队列
		for(var i = 0, len = exp.length; i < len; i++){
			var cur = exp[i];
			if(cur != ' ' ){
				inputStack.push(cur);
			}
		}
		console.log('step one');
		while(inputStack.length > 0){
			var cur = inputStack.shift();
			if(isOperator(cur)){
				if(cur == '('){
					outputStack.push(cur);
				}else if(cur == ')'){
					var po = outputStack.pop();
					while(po != '(' && outputStack.length > 0){
						outputQueue.push(po);
						po = outputStack.pop();
					}
					if(po != '('){
						throw "error: unmatched ()";
					}
				}else{
					while(prioraty(cur, outputStack[outputStack.length - 1]) && outputStack.length > 0){
						outputQueue.push(outputStack.pop());
					}
					outputStack.push(cur);
				}
			}else{
				outputQueue.push(new Number(cur));
			}
		}
		console.log('step two');
		if(outputStack.length > 0){
			if(outputStack[outputStack.length - 1] == ')' || outputStack[outputStack.length - 1] == '('){
				throw "error: unmatched ()";
			}
			while(outputStack.length > 0){
				outputQueue.push(outputStack.pop());
			}
		}
		console.log('step three');
		return outputQueue;

	}

	// console.log(dal2Rpn('1 + 2'));
	// console.log(dal2Rpn('1 + 2 + 3'));
	// console.log(dal2Rpn('1 + 2 * 3'));
	// console.log(dal2Rpn('1 + 2 * 3 - 4 / 5'));
	// console.log(dal2Rpn('( 1 + 2 )'));

	// console.log(dal2Rpn('( 1 + 2 ) * ( 3 - 4 ) / 5'));
	// console.log(dal2Rpn('( 1 + 2 ) * (( 3 - 4 ) / 5)'));


	function evalRpn(rpnQueue){
		var outputStack = [];
		while(rpnQueue.length > 0){
			var cur = rpnQueue.shift();

			if(!isOperator(cur)){
				outputStack.push(cur);
			}else{
				if(outputStack.length < 2){
					throw "unvalid stack length";
				}
				var sec = outputStack.pop();
				var fir = outputStack.pop();

				outputStack.push(getResult(fir, sec, cur));
			}
		}

		if(outputStack.length != 1){
			throw "unvalid expression";
		}else{
			return outputStack[0];
		}
	}
	console.log(evalRpn(dal2Rpn('( 1 + 2 ) * (( 3 - 4 ) / 5)')))

	function getResult(a,b,c){

		// var result = eval(Number(a) + c + Number(b))
		// console.log(result)
		// return result

		switch(c){
			case '+': return Number(a) + Number(b) 
			case '-': return Number(a) - Number(b) 
			case '*': return Number(a) * Number(b) 
			case '/': return Number(a) / Number(b) 
			case '%': return Number(a) % Number(b) 
			default: throw 'unvalid expression'
		}

	}


		// var arr = inputStr.split(' ').filter(it => it != '')
	//		console.log(arr)

			function calculator(arr){
				var tempArr = []
				var tempStr = ''
				arr.forEach(value => {
					// 数字
					if(/\d+/.test(value)){
						tempArr.push(value)
					}  


				})
			}



			// 建立二叉树
			var node = new Node()
			node.value = arr[0]
			var tree = buildTree(node, 0)
			console.log(tree)
			// 二叉树节点
			function Node(){
				this.value = null;
				this.leftChild = null;
				this.rightChild = null;
			}

			// 构建二叉树
			function buildTree(node, i) {
				var left = 2 * i + 1
				var right = 2 * i + 2
				// 左子树
				if(left < arr.length){
					var childNode = new Node()
					childNode.value = arr[left]
					node.leftChild = childNode
					buildTree(childNode, left)
				}
				// 右子树
				if(right < arr.length){
					var childNode = new Node()
					childNode.value = arr[right]
					node.rightChild = childNode
					buildTree(childNode, right)
				}
				return node
			}


		})

	</script>

</body>
</html>